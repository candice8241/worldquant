import json
from pathlib import Path
from time import sleep
 
import requests
from requests.auth import HTTPBasicAuth
 
 
def load_credentials():
    # 和 world2.py 同目录的 worldquant.txt
    cred_path = Path(__file__).resolve().with_name("worldquant.txt")
    with cred_path.open("r", encoding="utf-8") as f:
        credentials = json.load(f)
 
    # 期望格式: ["username", "password"]
    if not (isinstance(credentials, list) and len(credentials) == 2):
        raise ValueError('worldquant.txt 必须是 JSON 列表，例如: ["username","password"]')
 
    return credentials[0], credentials[1]
 
 
def authenticate(sess: requests.Session) -> None:
    resp = sess.post("https://api.worldquantbrain.com/authentication", timeout=30)
    print("auth status:", resp.status_code)
    try:
        print("auth json:", resp.json())
    except Exception:
        print("auth text:", resp.text[:500])
 
    resp.raise_for_status()
 
 
def get_datafields(
    s: requests.Session,
    searchScope: dict,
    dataset_id: str = "",
    search: str = "",
    limit: int = 50,
):
    import pandas as pd
 
    instrument_type = searchScope["instrumentType"]
    region = searchScope["region"]
    delay = searchScope["delay"]
    universe = searchScope["universe"]
 
    # 先请求第一页拿 count
    params = {
        "instrumentType": instrument_type,
        "region": region,
        "delay": str(delay),
        "universe": universe,
        "limit": limit,
        "offset": 0,
    }
    if dataset_id:
        params["dataset.id"] = dataset_id
    if search:
        params["search"] = search
 
    first = s.get("https://api.worldquantbrain.com/data-fields", params=params, timeout=30)
    if first.status_code == 429:
        sleep(float(first.headers.get("Retry-After", 5)))
        first = s.get("https://api.worldquantbrain.com/data-fields", params=params, timeout=30)
 
    if first.status_code != 200:
        raise RuntimeError(f"data-fields first page failed: {first.status_code}\n{first.text[:2000]}")
 
    payload = first.json()
    if "count" not in payload or "results" not in payload:
        raise RuntimeError(f"unexpected response (no count/results):\n{payload}")
 
    count = int(payload["count"])
    results_all = list(payload["results"])
 
    # 翻页
    for offset in range(limit, count, limit):
        params["offset"] = offset
        resp = s.get("https://api.worldquantbrain.com/data-fields", params=params, timeout=30)
 
        if resp.status_code == 429:
            sleep(float(resp.headers.get("Retry-After", 5)))
            resp = s.get("https://api.worldquantbrain.com/data-fields", params=params, timeout=30)
 
        if resp.status_code != 200:
            raise RuntimeError(f"data-fields page failed: {resp.status_code}\n{resp.text[:2000]}")
 
        page = resp.json()
        if "results" not in page:
            raise RuntimeError(f"unexpected response (no results):\n{page}")
 
        results_all.extend(page["results"])
 
    return pd.DataFrame(results_all)
 
 
def run_simulation(sess: requests.Session, alpha_payload: dict, poll_timeout_sec: int = 600):
    sim_resp = sess.post("https://api.worldquantbrain.com/simulations", json=alpha_payload, timeout=30)
 
    if sim_resp.status_code == 429:
        sleep(float(sim_resp.headers.get("Retry-After", 5)))
        sim_resp = sess.post("https://api.worldquantbrain.com/simulations", json=alpha_payload, timeout=30)
 
    if sim_resp.status_code not in (200, 201, 202):
        raise RuntimeError(f"simulation submit failed: {sim_resp.status_code}\n{sim_resp.text[:2000]}")
 
    progress_url = sim_resp.headers.get("Location")
    if not progress_url:
        raise RuntimeError(f"no Location header in simulation response:\n{sim_resp.text[:2000]}")
 
    waited = 0.0
    while True:
        prog = sess.get(progress_url, timeout=30)
        if prog.status_code == 429:
            sleep(float(prog.headers.get("Retry-After", 5)))
            waited += float(prog.headers.get("Retry-After", 5))
            continue
 
        prog.raise_for_status()
 
        retry_after = float(prog.headers.get("Retry-After", 0) or 0)
        if retry_after == 0:
            data = prog.json()
            alpha_id = data.get("alpha")
            if not alpha_id:
                raise RuntimeError(f"simulation finished but no alpha id:\n{data}")
            return alpha_id, data
 
        sleep(retry_after)
        waited += retry_after
        if waited > poll_timeout_sec:
            raise TimeoutError(f"poll timeout (> {poll_timeout_sec}s): {progress_url}")
 
 
def main():
    username, password = load_credentials()
 
    sess = requests.Session()
    sess.auth = HTTPBasicAuth(username, password)
 
    authenticate(sess)
 
    searchScope = {
        "region": "USA",
        "delay": 1,
        "universe": "TOP3000",
        "instrumentType": "EQUITY",
    }
 
    fundamental6 = get_datafields(sess, searchScope=searchScope, dataset_id="fundamental6")
 
    # 筛选 type = MATRIX
    if "type" in fundamental6.columns:
        fundamental6 = fundamental6[fundamental6["type"] == "MATRIX"]
 
    datafields_list_fundamental6 = fundamental6["id"].dropna().astype(str).values
    print("datafields:", datafields_list_fundamental6)
    print("count:", len(datafields_list_fundamental6))
 
    # 生成 alpha payload 列表
    alpha_list = []
    for index, datafield in enumerate(datafields_list_fundamental6, start=1):
        alpha_expression = f"group_rank(({datafield})/cap, subindustry)"
        simulation_data = {
            "type": "REGULAR",
            "settings": {
                "instrumentType": "EQUITY",
                "region": "USA",
                "universe": "TOP3000",
                "delay": 1,
                "decay": 0,
                "neutralization": "SUBINDUSTRY",
                "truncation": 0.08,
                "pasteurization": "ON",
                "unitHandling": "VERIFY",
                "nanHandling": "ON",
                "language": "FASTEXPR",
                "visualization": False,
            },
            "regular": alpha_expression,
        }
        alpha_list.append(simulation_data)
        print(f"[{index}/{len(datafields_list_fundamental6)}] built:", alpha_expression)
 
    if len(alpha_list) > 1:
        print("sample alpha payload:", alpha_list[1])
 
    # 建议先测试前两个
    for index, alpha in enumerate(alpha_list, start=1):
        print(f"simulate {index}/{len(alpha_list)} ...")
        alpha_id, _ = run_simulation(sess, alpha)
        print("alpha_id:", alpha_id)
 
 
if __name__ == "__main__":
    main()
